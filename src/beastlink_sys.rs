/* automatically generated by rust-bindgen */

#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#[link(name="beastlink-1.0")]
#[link(name="udk3-1.5.1")]

pub const BL_IF_BUFFER_SIZE: ::std::os::raw::c_uint = 16384;
pub const BL_SUCCESS: ::std::os::raw::c_uint = 0;
pub const BL_INVALID_DEVICE: ::std::os::raw::c_int = -1;
pub const BL_FLAG_CONST_ADDR: ::std::os::raw::c_uint = 1;
/**
 * Return code for every function that may have an error condition.
 */
pub type BL_RESULT = ::std::os::raw::c_int;
/**
 * Data type to use for a device handle.
 */
pub type BL_DEVICE_HANDLE = ::std::os::raw::c_int;
extern "C" {
    /**
 * Return error text of last exception. The id value is the return code of the
 * failed function invocation. Every id is unique and can only be used once
 * calling this function (it is removed from the internal error collector
 * after the first access). buffer must be of size BL_IF_BUFFER_SIZE and
 * contains a 0-terminated string after the invocation.
 */
    pub fn BlGetLastErrorText(id: ::std::os::raw::c_int,
                              buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    /**
 * Initialize API components.
 */
    pub fn BlInit() -> BL_RESULT;
}
extern "C" {
    /**
* Cleanup API components.
*/
    pub fn BlCleanup() -> BL_RESULT;
}
extern "C" {
    /**
 * Return full of BeastLink library.
 */
    pub fn BlGetVersion(major: *mut ::std::os::raw::c_int,
                        minor: *mut ::std::os::raw::c_int,
                        fix: *mut ::std::os::raw::c_int) -> BL_RESULT;
}
extern "C" {
    /**
 * Set logging level (Off = 0, Error = 1, Warning = 2, Debug = 3), default is 2.
 */
    pub fn BlSetLogLevel(ll: ::std::os::raw::c_int) -> BL_RESULT;
}
extern "C" {
    /**
 * Enumerates devices with the given VID and PID. count returns number of devices found.
 */
    pub fn BlEnumerate(vid: ::std::os::raw::c_ushort,
                       pid: ::std::os::raw::c_ushort,
                       count: *mut ::std::os::raw::c_int) -> BL_RESULT;
}
extern "C" {
    /**
 * Access device. enumId must be in range 0 to count (count returned by BlEnumerate()). A new call
 * to BlEnumerate invalidates the numbers for this id. The returned handle must be used for
 * every subsequent communication with the device. An opened device isn't reported in
 * any subsequent enumeration (system wide), until it's closed.
 */
    pub fn BlOpen(enumId: ::std::os::raw::c_int,
                  handle: *mut BL_DEVICE_HANDLE) -> BL_RESULT;
}
extern "C" {
    /**
 * Free access to device. After this call the device is available in new enumerations.
 */
    pub fn BlClose(handle: BL_DEVICE_HANDLE) -> BL_RESULT;
}
extern "C" {
    /**
 * Read 32 bit register value. handle is returned from BlOpen(). reg specifies the register
 * in FPGA address space. result contains the value read from device.
 */
    pub fn BlReadRegister(handle: BL_DEVICE_HANDLE,
                          reg: ::std::os::raw::c_uint,
                          result: *mut ::std::os::raw::c_uint) -> BL_RESULT;
}
extern "C" {
    /**
 * Write 32 bit register value. handle is returned from BlOpen(). reg specifies the register
 * in FPGA address space. value will be the new value.
 */
    pub fn BlWriteRegister(handle: BL_DEVICE_HANDLE,
                           reg: ::std::os::raw::c_uint,
                           value: ::std::os::raw::c_uint) -> BL_RESULT;
}
extern "C" {
    /**
 * Read data block. handle is returned from BlOpen(). addr is the address in FPGA address space to which
 * the data is transferred. buffer is the pointer to the data the should be send. size is the count
 * of bytes to transfer. flags can be (see their individual documentation):
 *   - BL_FLAG_CONST_ADDR
 */
    pub fn BlReadBlock(handle: BL_DEVICE_HANDLE, addr: ::std::os::raw::c_uint,
                       buffer: *mut ::std::os::raw::c_void,
                       size: ::std::os::raw::c_int,
                       flags: ::std::os::raw::c_int) -> BL_RESULT;
}
extern "C" {
    /**
 * Write data block. handle is returned from BlOpen(). addr is the address in FPGA address space from which
 * the data is transferred. buffer is the pointer to which received data is stored. size is the count
 * of bytes to transfer. flags can be (see their individual documentation):
 *   - BL_FLAG_CONST_ADDR
 */
    pub fn BlWriteBlock(handle: BL_DEVICE_HANDLE,
                        addr: ::std::os::raw::c_uint,
                        buffer: *mut ::std::os::raw::c_void,
                        size: ::std::os::raw::c_int,
                        flags: ::std::os::raw::c_int) -> BL_RESULT;
}
extern "C" {
    /**
 * Pulse FPGA reset line (the I/O that is chosen to be reset). Useful to bring the FPGA
 * in a defined state. Implicitly done after FPGA programming. handle is returned from BlOpen().
 */
    pub fn BlResetFpga(handle: BL_DEVICE_HANDLE) -> BL_RESULT;
}
extern "C" {
    /**
 * Configure FPGA with given design in file. handle is returned from BlOpen().
 * Loads a .bin from as specified by fileName and programs the FPGA using this design.
 * Subsequently pulses the reset line.
 */
    pub fn BlProgramFpgaFromBin(handle: BL_DEVICE_HANDLE,
                                fileName: *const ::std::os::raw::c_char)
     -> BL_RESULT;
}
extern "C" {
    /**
 * Configure FPGA with given design in memory. Useful when compiling FPGA designs into the executable.
 * BoardManager creates sources that can be used this way.
 * The reset line is pulsed subsequently.
 */
    pub fn BlProgramFpgaFromMemory(handle: BL_DEVICE_HANDLE,
                                   buffer: *mut ::std::os::raw::c_void,
                                   size: ::std::os::raw::c_int,
                                   compressed: ::std::os::raw::c_int)
     -> BL_RESULT;
}
extern "C" {
    /**
 * Configure timeout until a pending transfer is stopped and defined as failed.
 * This timeout is used for all transfers to and from device.
 * handle is returned from BlOpen(). timeout must be specified in milliseconds.
 */
    pub fn BlSetTimeout(handle: BL_DEVICE_HANDLE,
                        timeout: ::std::os::raw::c_uint) -> BL_RESULT;
}
extern "C" {
    /**
 * Set user ID. Writes the 0 - terminated string in buffer to the device EEPROM.
 * This ID is intended to differentiate multiple devices of the same type connected
 * to one host. The ID can contain up to 63 ASCII characters.
 */
    pub fn BlSetUserId(handle: BL_DEVICE_HANDLE,
                       buffer: *mut ::std::os::raw::c_char) -> BL_RESULT;
}
extern "C" {
    /**
 * Return user ID from device EEPROM as 0 - terminated string. See explanation in
 * BlSetUserId().
 */
    pub fn BlGetUserId(handle: BL_DEVICE_HANDLE,
                       buffer: *mut ::std::os::raw::c_char) -> BL_RESULT;
}
extern "C" {
    /**
 * Return derivate info string. handle is returned from BlOpen(). buffer must be of
 * size BL_IF_BUFFER_SIZE.
 * Some devices are available in different versions (different FPGA's, different peripherals).
 * The returned 0 - terminated string contains a textual information about the specific
 * derivate. For programmatically differentiation, BlGetDerivateId() is better suited.
 */
    pub fn BlGetDerivateInfo(handle: BL_DEVICE_HANDLE,
                             buffer: *mut ::std::os::raw::c_char)
     -> BL_RESULT;
}
extern "C" {
    /**
 * Return derivate id. handle is returned from BlOpen(). This ID is unique for every
 * derivate of a specific device type. Existing derivates can be found in the documentation
 * of the specific device type.
 */
    pub fn BlGetDerivateId(handle: BL_DEVICE_HANDLE,
                           derivateId: *mut ::std::os::raw::c_uint)
     -> BL_RESULT;
}
extern "C" {
    /**
 * Return serial number as 0 - terminated string. Not supported by all device types / instances.
 * handle is returned from BlOpen(). buffer must be of size BL_IF_BUFFER_SIZE.
 */
    pub fn BlGetSerialNumber(handle: BL_DEVICE_HANDLE,
                             buffer: *mut ::std::os::raw::c_char)
     -> BL_RESULT;
}
extern "C" {
    /**
 * Return firmware version. handle is returned from BlOpen().
 * buffer must be of size BL_IF_BUFFER_SIZE.
 */
    pub fn BlGetFirmwareVersion(handle: BL_DEVICE_HANDLE,
                                major: *mut ::std::os::raw::c_int,
                                minor: *mut ::std::os::raw::c_int,
                                fix: *mut ::std::os::raw::c_int) -> BL_RESULT;
}
